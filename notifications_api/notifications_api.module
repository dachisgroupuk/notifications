<?php

/**
 * A notification api framework
 * 
 * @author Rachel Graves
 */
 
/**
 * Implements hook_menu_alter().
 */
function notifications_api_menu_alter(&$items) {
  
  // Take over the access callback for broadcast messages in og
  $items['node/%node/broadcast']['access callback'] = 'notifications_og_broadcast_access';
  
}

/**
 * Allows the broadcast option for admins of the group
 *
 * @param string $node 
 * @return bool
 * @author Maarten Jacobs
 */
function notifications_og_broadcast_access($node) {
  return og_is_group_admin($node);
}

/**
 * Prepare a notification factory.
 * Call any module implementing hook_innodev_notify,
 * hook_innodev_notify_alter and 
 * Produce a suitable notification based on the return
 *
 * @param $type String the 
 * @author Rachel Graves
 */
function notifications_api_notify($type, $op, $payload) {
  
  // Produce a notification object
  $factories = _notifications_api_generate_notifications($type, $op, $payload);
  
  // Allow a module to alter a notification
  $factories = _notifications_api_alter($factories);
  
  // Tell factories to send their notifications via Royal Mail
  foreach($factories as $factory) {
    $factory->send();
  }
  
}


/**
 * Generates the notifications per module
 *
 * @return array of Notifications_Api_Factory_Queue
 * @author Maarten Jacobs
 */
function _notifications_api_generate_notifications($type, $op, $payload) {
  
  $factories = array();

  foreach (module_implements('notifications_api_generate') as $module) { 
    $factory = new Notifications_Api_Factory_Queue($module, $type, $op, $payload);
    
    $function = $module . '_notifications_api_generate';
    $function($factory);
    $factories[] = $factory;
  }
  
  return $factories;
  
}

/**
 * Calls the alter hook on the generated Factories
 *
 * @param array $factories 
 * @return array
 * @author Maarten Jacobs
 */
function _notifications_api_alter($factories) {
  drupal_alter('notifications_api', $factories);
  return $factories;
}


/**
 * First try and call hook_innodev_notify_TYPE_OP
 * Then try and call hook_innodev_notify
 *
 * @author Rachel Graves
 */
function _notifications_api_hook_innodev_notify($type, $op, $payload) {

  $notification = new Innodev_Notification($type, $op, $payload);
            
  if(file_exists($file)) {

    require_once($file);

  } else {
    foreach (module_implements('innodev_notify') as $module) {        
      $function = $module . '_' . 'innodev_notify';
      return call_user_func_array($function, $args);
    }
  }
  
}

class Recipient implements IRecipient {
  
  protected $_type;
  protected $_data;
  
  /**
   * Returns the type of the recipient, to be set by the recipient creator.
   *
   * @return string
   * @author Maarten Jacobs
   */
  public function getType() {
    return $this->_type;
  }
  
  /**
   * Represents the data representing the recipient, of any arbitrary type.
   *
   * @return mixed
   * @author Maarten Jacobs
   */
  public function getData() {
    return $this->_data;
  }
  
  public function __construct($type, $data) {
    $this->_data = $data;
    $this->_type = '' . $type;
  }
  
}

/**
 * Representation of the Recipient of a notification
 *
 * @package notifications_api
 * @author Maarten Jacobs
 */
interface IRecipient {
  
  /**
   * Returns the type of the recipient, to be set by the recipient creator.
   *
   * @return string
   * @author Maarten Jacobs
   */
  public function getType();
  /**
   * Represents the data representing the recipient, of any arbitrary type.
   *
   * @return mixed
   * @author Maarten Jacobs
   */
  public function getData();
  
  public function __construct($type, $data);
  
}

class Notifications_Api_Factory_Queue implements Iterator {
 
  /**
   * Object ID
   */
  protected $_id;

  /**
   * Node or comment type notification
   */
  protected $_type;

  /**
   * Nodeapi or Comment operation
   */
  protected $_op;
  
  /**
   * Typically a node or comment object
   */
  protected $_payload;
  
  /**
   * Uids that will receive this notification
   */
  protected $_uids;
  
  /**
   * Notification message
   */
  protected $_message;
  
  /**
   * Uid that initiated this notification
   */
  protected $_initiatorUid;
  
  /**
   * Source of the notification
   *
   * @var string
   */
  protected $_moduleImplements;
  
  /**
   * Array of notification objects
   *
   * @var array
   */
  protected $_notifications;  
 
  function __construct($module_implements, $type, $op, $payload) {
    $this->_moduleImplements = $module_implements;
    $this->_type = $type;
    $this->_op = $op;
    $this->_payload = $payload;
    $this->_id = uniqid('notifications_api_notification');
    
    // Initialise as an array
    $this->_notifications = array();
  }
  
  /**
   * undocumented function
   *
   * @return void
   * @author Rachel Graves
   */
  public function generateNotification() {
    return new Notifications_Api_Notification($this->_moduleImplements, $this->_type, 
      $this->_op, $this->_payload, $this);
  }
  
  /**
   * Store a notification back in the bender factory
   *
   * @param Notifications_Api_Notification $notification 
   * @return void
   * @author Rachel Graves
   */
  public function storeNotification(Notifications_Api_Notification $notification) {
    $this->_notifications[$notification->getId()] = $notification;
  }
  
  /**
   * Instruct notifications to send
   *
   * @return void
   * @author Rachel Graves
   */
  public function send() {
    foreach($this->_notifications as $notification) {
      $notification->send();
    }
  }
  
  public function getType() {
    return $this->_type;
  }

  public function getOp() {
    return $this->_op;
  }

  public function getPayload() {
    return $this->_payload;
  }
  
  public function getModuleImplements() {
    return $this->_moduleImplements;
  }
  
  public function rewind() {
    reset($this->_notifications);
  }

  public function current() {
    return current($this->_notifications);
  }

  public function key() {
    return key($this->_notifications);
  }

  public function next() {
    return next($this->_notifications);
  }

  public function valid() {
    $key = key($this->_notifications);
    return ($key !== NULL && $key !== FALSE);
  }
  
  /**
   * Updates a given notification by key, first checking if it's the same notification.
   *
   * @param string $key 
   * @param Notifications_Api_Notification $notification 
   * @return mixed
   * @author Maarten Jacobs
   */
  public function updateNotification($key, Notifications_Api_Notification $notification) {
    if (!array_key_exists($key, $this->_notifications) || $this->_notifications[$key]->getId() !== $notification->getId()) {
      return FALSE;
    }
    $this->_notifications[$key] = $notification;
    return $this;
  }
  
  /**
   * Test function
   * TODO: REMOVE ME
   *
   * @return void
   * @author Maarten Jacobs
   */
  public function getNotifications() {
    return $this->_notifications;
  }
  
}

class Notifications_Api_Notification {

  /**
   * Object ID
   */
  protected $_id;

  /**
   * Node or comment type notification
   */
  protected $_type;

  /**
   * Nodeapi or Comment operation
   */
  protected $_op;
  
  /**
   * Typically a node or comment object
   */
  protected $_payload;
  
  /**
   * Uids that will receive this notification
   */
  protected $_recipients;
  
  /**
   * Notification message
   */
  protected $_message;
  
  /**
   * Uid that initiated this notification
   */
  protected $_initiator;
  
  /**
   * Source of the notification
   *
   * @var string
   */
  protected $_moduleImplements;
  
  /**
   * Array of callback functions for this notification
   *
   * @var array
   */
  public $callbacks;
  
  /**
   * Assign properties to this object
   */
  public function __construct($module_implements, $type, $op, $payload, Notifications_Api_Factory_Queue &$factory) {
    $this->_moduleImplements = $module_implements;
    $this->_type = $type;
    $this->_op = $op;
    $this->_payload = $payload;
    $this->_id = uniqid('notifications_api_notification');
    $this->_factory = $factory;
    
    // Initilaise callbacks as an array and set the default callback function
    $this->callbacks = array();
    $this->callbacks[] = $module_implements . '_notifications_api_send';
  }
  
  public function getId() {
    return $this->_id;
  }

  public function getType() {
    return $this->_type;
  }

  public function getOp() {
    return $this->_op;
  }

  public function getPayload() {
    return $this->_payload;
  }
  
  public function getModuleImplements() {
    return $this->_moduleImplements;
  }
  
  public function getTos() {
    return $this->_recipients;
  }
  
  public function getMessage() {
    return $this->_message;
  }
  
  public function setMessage($message) {
    $this->_message = $message;
    return $this;
  }

  public function setSender($sender) {
    $this->_initiator = $sender;
    return $this;
  }

  /**
   * Send this notification
   */
  public function send() {
    $callable_callbacks = array_filter($this->callbacks, 'is_callable');
    foreach ($callable_callbacks as $callback) {
      call_user_func($callback, $this);
    }
  }

  /**
   * Store a notification back in the PG tips factory
   *
   * @return void
   * @author Rachel Graves
   */
  public function store() {
    $this->_factory->storeNotification($this);
  }
  
  /**
   * Adds a recipient to the list of recipients
   *
   * @param string $type 
   * @param mixed $data 
   * @return Notifications_Api_Notification
   * @author Maarten Jacobs
   */
  public function addTo($type, $data) {
    
    if ($type instanceof IRecipient) {
      $recipient = $type;
    } else {
      $recipient = new Recipient($type, $data);      
    }  
    $this->_addRecipient($recipient);
    
    return $this;
  }
  
  /**
   * Set the recipients list to a single recipient,
   * effectively erasing the list of recipients.
   *
   * @param string $type 
   * @param mixed $data 
   * @return Notifications_Api_Notification
   * @author Maarten Jacobs
   */
  public function setTo($type, $data) {
    
    if ($type instanceof IRecipient) {
      $recipient = $type;
    } else {
      $recipient = new Recipient($type, $data);      
    }  
    
    return $this->_addRecipient($recipient);
  }
  
  protected function _addRecipient(IRecipient $recipient) {
    $this->_recipients[] = $recipient;
    return $this;
  }

}
